```sql


create table public.business_images (
  id bigint generated by default as identity not null,
  business_id uuid not null,
  path text not null,
  path_thumbnail text null,
  "primary" boolean null default false,
  created_at timestamp with time zone not null default now(),
  constraint business_images_pkey primary key (id),
  constraint business_id_fkey foreign KEY (business_id) references businesses (id)
) TABLESPACE pg_default;

-----trigger para actualizar las tablas cuando se sube una imagen al bucket-------------
create or replace function public.handle_business_image_upload()
returns trigger
language plpgsql
security definer
as $$
declare
  v_business_id uuid;
  v_thumb_path text;
  v_is_logo boolean;
  v_is_banner boolean;
begin
  -- Solo bucket correcto
  if new.bucket_id <> 'business_images' then
    return new;
  end if;

  -- Extraer metadata
  v_business_id := (new.user_metadata ->> 'business_id')::uuid;
  v_is_logo := coalesce((new.user_metadata ->> 'logo')::boolean, false);
  v_is_banner := coalesce((new.user_metadata ->> 'banner')::boolean, false);

  if v_business_id is null then
    return new;
  end if;

  -- CASO LOGO
  if v_is_logo then
    update public.businesses
    set logo = new.name
    where id = v_business_id;

    return new;
  end if;

  -- CASO BANNER
  if v_is_banner then
    update public.businesses
    set banner = new.name
    where id = v_business_id;

    return new;
  end if;

  -- CASO IMAGEN NORMAL
  v_thumb_path := replace(new.name, 'full_', 'thumb_');

  insert into public.business_images (
    business_id,
    path,
    path_thumbnail
  )
  values (
    v_business_id,
    new.name,
    v_thumb_path
  );

  return new;
end;
$$;


-- trigger cuando se sube una imagen 
DROP TRIGGER IF EXISTS on_business_image_uploaded ON storage.objects;

create trigger on_business_image_uploaded
after insert on storage.objects
for each row
execute function public.handle_business_image_upload();


-----trigger para actualizar las tablas cuando se elimina una imagen del bucket---------------------

create or replace function public.handle_business_image_delete()
returns trigger
language plpgsql
security definer
as $$
declare
  v_thumb_path text;
begin
  if old.bucket_id <> 'business_images' then
    return old;
  end if;

  -- CASO LOGO
  update public.businesses
  set logo = null
  where logo = old.name;

  if found then
    return old;
  end if;

  -- CASO BANNER
  update public.businesses
  set banner = null
  where banner = old.name;

  if found then
    return old;
  end if;

  -- CASO THUMBNAIL
  if old.name like '%/thumb_%' then
    update public.business_images
    set path_thumbnail = null
    where path_thumbnail = old.name;

    return old;
  end if;

  -- CASO IMAGEN FULL
  if old.name like '%/full_%' then
    select path_thumbnail
    into v_thumb_path
    from public.business_images
    where path = old.name;

    -- borrar thumbnail asociado
    if v_thumb_path is not null then
      delete from storage.objects
      where bucket_id = old.bucket_id
        and name = v_thumb_path;
    end if;

    delete from public.business_images
    where path = old.name;

    return old;
  end if;

  return old;
end;
$$;


create trigger on_business_image_deleted
after delete on storage.objects
for each row
execute function public.handle_business_image_delete();

--------------------------------------------------------

  
ALTER TABLE public.business_images ENABLE ROW LEVEL SECURITY;

create policy "businesses can read images"
on public.business_images
for select
using (true);

-- UPDATE primary
create policy "businesses can update primary image"
on public.business_images
for update
using (auth.uid() = business_id)
with check (auth.uid() = business_id);

```
